[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Acerca",
    "section": "",
    "text": "CentroGeo es un Centro Público de Investigación, parte del Sistema de Centros Conacyt\n\n\n\n\n\n\nNoé Osorio García \n\n\n\n\n \n\n\n\n\n\nPablo López Ramírez"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny en una sentada",
    "section": "",
    "text": "Introducción\nBienvenidos al tutorial para desarrollar un visualizador geográfico súper simple utilizando Shiny. Este taller fue desarrollado como parte de las actividades de la Semana de Divulgación de las Ciencias de Información Geoespacial 2022 de CentroGeo.\nShiny es una herramienta desarrollada por RStudio para crear, de forma sencilla y usando únicamente el lenguaje de programación R, tableros interactivos de visualización de datos. R provee paquetes de visualización y análisis estadístico muy poderosos, Shiny nos ayuda a usar estas funcionalidades de R en la cosntrucción de visualizaciones interactivas, abriendo a los analistas dde datos la posibilidad de generar herramientas de comunicación sin recurrir directamente a tecnologías Web como Javascript o HTML.\nEl objetivo del taller es guiarte paso a paso en el desarrollo de un tablero de visualización muy simple que incluya un mapa y un par de graficos dinámicos. Vamos a trabajar cn datos del Secretariado Ejecutivo del Sistema Nacional de Seguridad Pública sobre incidencia delictiva en México. Para podr concentrarnos en este taller sólo en lo que tiene que ver con Shiny, vamos a usar una versión preprocesada de los datos abiertos. Como gui, en la siguiente figura presentamos un wireframe del tablero que vamos a desarrollar.\n\n\n\nWireframe del tablero de visualización\n\n\n\n\nRequisitos previos\nAntes que nada, para seguir el taller es necesario que tengas una carpeta organizada de la siguiente forma:\nproyecto \n│   app.R    \n└───01_input\n│   │   Mapa_scatter_delitos_prioritarios.rds\n│   │   ts_delitos_prioritarios.rds\nLos datos los puedes bajar de aquí:\n\nMapa_scatter_delitos_prioritarios.rds\nts_delitos_prioritarios.rds\n\nAdemás tenemos que tener instalados, además de R (aquí encuentras las instrucciones para instalarlo), una serie de paquetes:\n\ninstall.packages(\"shiny\")\ninstall.packages(\"tidyverse\")\ninstall.packages(\"sf\")\ninstall.packages(\"ggrepel\")\ninstall.packages(\"leaflet\")\n\nLa instalación de estos paquetes depende un poco de cada plataforma (windows, linux, Mac), pero en general debería ser relativamente simple.\nPara desarrollar la aplicación puedes usar el IDE para R Rstudio o Visual Studio con la extensión de R instalada.\n\n\nEstructura del taller\nUna ves que hemos cubierto los requisitos previos, podemos empezar a trabajar en nuestro visualizador. El taller está estructurado de la siguiente forma:\n\nEn la Sección Gráficas vamos a ver cómo se hacen individualmente los componentes de la aplicación:\n\nScatterplot\nSerie de tiempo\nMapa\n\nEn la sección Tablero, vamos a juntar estos elementos y programar la interactividad."
  },
  {
    "objectID": "integrando.html#introducción",
    "href": "integrando.html#introducción",
    "title": "Integrando en una aplicación",
    "section": "Introducción",
    "text": "Introducción\nYa tenemos todos los elementos que necesitamos, en las secciones Serie de Tiempo, Diagrama de dispersión y Mapa desarrollamos cada elemento de la aplicación, ahora lo que tenemos que hacer es integrar todo en un flujo interactivo.\nComo vimos antes, las aplicaciones de Shiny estan compuestas de dos piezas: la interfaz de usuario y el servidor. La interfaz de usuario en nuestro caso es relativamente sencilla, contiene cuatro elementos fundamentales: el selector de delito y las salidas de los tres componentes.\nEn una aplicación Web normal, la estructura de la interfaz de usuario se define utilizando una combinación de html y css. Shiny nos provee una seri de funciones de R que generan los componentes Web que necesitamos. Por ejemplo, digamos que queremos hacer un radio button utilizando Shiny:\n\nradioButtons(\"est\", \"Estación:\",\n    c(\"Radio Universal\" = \"ru\",\n      \"La pantera\" = \"590\")\n)\n\n\nEstación:\n\n\n\n\nRadio Universal\n\n\n\n\n\nLa pantera\n\n\n\n\n\n\nLa función radioButtons nos regresa el código de html para que en la página aparezcan nuestros botones.\nRegresando a nuestra apliacación, generar un selector para los diferentes tipos de delitos de la base de datos es muy fácil:\n\n selectInput(\"id_delito\",\"Selecciona un delito\",\n            c(\"Robo a casa habitación\",\n               \"Robo a negocio\",                   \n               \"Robo a transeúnte\",                \n               \"Robo a transportista\",\n               \"Robo en transporte público colectivo\",\n               \"Robo en transporte público individual\",\n               \"Robo de vehículo automotor\",\n               \"Extorsión\",                         \n               \"Feminicidio\",                   \n               \"Homicidio doloso\",\n               \"Secuestro\")\n    )\n\n\nSelecciona un delito\n\nRobo a casa habitación\nRobo a negocio\nRobo a transeúnte\nRobo a transportista\nRobo en transporte público colectivo\nRobo en transporte público individual\nRobo de vehículo automotor\nExtorsión\nFeminicidio\nHomicidio doloso\nSecuestro"
  },
  {
    "objectID": "integrando.html#navegación",
    "href": "integrando.html#navegación",
    "title": "Integrando en una aplicación",
    "section": "Navegación",
    "text": "Navegación\nEl elemento que nos falta para integrar nuestras gráficas en un solo tablero de visualizacioón es definir la estructura general de navegación y la disposición de los elementos en la página. Shiny provee un conjunto de funciones que generan contenedores para diferentes estructuras de navegación, la gúia de diseño de Shiny es un buen punto para empezar a entender estas estructuras. Lo que nosotros vamos a hacer es utilizar un contenedor de tipo navbarPage como elemento más externo, adentro de este vamos a poner un [tabPanel](https://shiny.rstudio.com/reference/shiny/0.12.1/tabPanel que va a contener las filas y columnas en los que vamos a organizar nuestros elementos visuales.\n\nnavbarPage(\n    title = \"Visualizador de delitos\",\n    fluid = TRUE,\n    collapsible = TRUE,\n    tabPanel(\n        \"Un título\",\n        fluidRow(\n            tagList(\n                column(\n                    # Nuestro selector de delitos\n                ),\n                column(\n                    # Nuestro mapa\n                ),\n                column(\n                    # Serie de tiempo\n                ),\n                column(\n                    # Scatterplot\n                )\n            )\n        )\n    )\n)\n\nFíjense cómo estamos usando el elemento fluidRow para crear la retícula en la que vamos a desplegar nuestros elementos. Como pueden ver sólo definimos columnas adentro del fluid row, la forma en la que se organizan internamente esas columnas va a depender de su tamaño relativo y del tamaño de la pantalla en la que se visualicen. Esta forma de organizar el contenido se llama Bootstrap grid system y es muy útil para diseñar páginas que se adapten de forma automática a diferentes dispositivos."
  },
  {
    "objectID": "integrando.html#servidor",
    "href": "integrando.html#servidor",
    "title": "Integrando en una aplicación",
    "section": "Servidor",
    "text": "Servidor\nLo que nos falta ahora es la lógica del servidor, es decir, las funciones que se van a encargar de tomar el input del usuario y regresar las gráficas. En la Sección Mi primera aplicación vimos cómo hacer funciones que regresen elementos visuales para acomodarlos donde queremos. Ahora vamos a hacer lo mismo pero con nuestras gráficas, por ejemplo, para construir la serie de tiempo y ponerla en la columna que le toque:\n\noutput$serie <- renderPlot({\nbase_ts() %>% \n    filter(subtipo_de_delito==input$id_delito) %>%\n    ggplot(aes(fecha,Total)) +\n    geom_line() +\n    geom_point(data = . %>% \n                filter(Total==max(Total)),\n                size=3,col=\"red\"\n    ) +\n    geom_point(data = . %>% \n                filter(fecha==max(fecha)),\n                size=3\n    ) +\n    theme_classic()\n})\n\nAquí estamos suponiendo que en la columna que queremos tenemos un elemento plotOutput(serie). Lo único especial de este código es la llamada a la función base_ts() en la gráfica original base_ts son los datos con los que construimos la gráfica, en este caso base_ts() es una expresión reactiva de Shini que transforma la base de datos en una función que sólo se consulta en el momento en el que se necesita, esto permite desarrollar la interactividad de forma más rápida y eficiente:\n\n#|eval: false\nbase_ts <- reactive({\n    base_ts\n})\n\nEntonces, la función completa del servidor, suponiendo que en las columnas correspondientes tenemos los elementos leafletOutput (para el mapa) y plotOutput para las gráficas, se vería así:\n\n#|eval: false\nserver <- function(input, output) {\n  \n  #Reactividad  de los mapas\n  b_mapa <- reactive({\n    base_mapa %>% \n      filter(fecha==as.Date(\"2022-08-01\"))\n  })\n  # Reactividad de la serie\n  b_ts <- reactive({\n    base_ts\n  })\n  # Reactividad del scatter\n  b_scatter <- reactive({\n    base_mapa\n  })\n  # Mapa leaflet\n  output$mapa <- renderLeaflet({\n    base <- b_mapa()[b_mapa()$subtipo_de_delito == input$id_delito,]\n    pal <- colorNumeric(palette = \"inferno\",domain = b_mapa()[b_mapa()$subtipo_de_delito == input$id_delito,]$Total)    \n    \n    leaflet() %>% \n      addProviderTiles(providers$OpenStreetMap) %>% \n      addPolygons(data = base$geometry,\n                  fillColor = pal(base$Total),\n                  color = \"black\",\n                  weight = 1,\n                  opacity = 1,\n                  fillOpacity = .7,\n                  label = base$NOMGEO,\n                  group = \"Entidades\")%>% \n      addLegend(pal = pal,values = base$Total) %>% \n      addLayersControl(overlayGroups = \"Entidades\")\n  })\n  # Mapa serie de tiempo\n  output$serie <- renderPlot({\n    b_ts() %>% \n      filter(subtipo_de_delito == input$id_delito) %>%\n      ggplot(aes(fecha,Total))+\n      geom_line()+\n      geom_point(data = . %>% \n                   filter(Total == max(Total)),\n                 size = 3,col = \"red\"\n      )+\n      geom_point(data = . %>% \n                   filter(fecha == max(fecha)),\n                 size = 3\n      )+\n      theme_classic()\n  })\n  \n  #Scatter PLot \n  \n  output$scatter <- renderPlot({\n    base <- b_scatter() %>% \n      filter(subtipo_de_delito == input$id_delito)\n    \n    ejes <- base %>% filter(Total == max(Total))\n    \n    base %>% \n      filter(subtipo_de_delito == input$id_delito) %>% \n      st_drop_geometry() %>%\n      pivot_wider(id_cols = c('clave_ent','entidad'),\n                  names_from = 'fecha',\n                  values_from = 'Total') %>% \n      ggplot(aes(`2022-07-01`,`2022-08-01`)) +\n      geom_point() +\n      scale_y_continuous(limits = c(0,ejes$Total)) +\n      scale_x_continuous(limits = c(0,ejes$Total)) +\n      geom_abline() +\n      theme_classic() +\n      ggrepel::geom_text_repel(aes(label=entidad))\n    \n  })\n}\n\nComo pueden ver, sólo se trata de empaquetar el flujo con el que hacemos cada una de las gráficas en la función de Shiny correspondiente y asignar el resultado al elemento de output que queramos. Hacer una aplicación de Shiny es sólo un poco más copmplicado que hacer cada una de las gráficas y, justo esa, es la gran ventaja de Shiny!"
  },
  {
    "objectID": "integrando.html#código-final",
    "href": "integrando.html#código-final",
    "title": "Integrando en una aplicación",
    "section": "Código final",
    "text": "Código final\nFinalmente, ya sólo necesitamos integrar todo el código en una sola aplicación bajo el modelo de Shiny. Eso implica crear dos funciones: un shinyUI y un server, luego ponemos las dos funciones en un archivo único app.R y llamamos a la función shinyApp(ui = ui, server = server) para levantar la aplicación. El código completo lo puedes ver a continuación:\n\n#|eval: false\nSys.setlocale(\"LC_ALL\", \"Spanish\")\n\nWarning in Sys.setlocale(\"LC_ALL\", \"Spanish\"): OS reports request to set locale\nto \"Spanish\" cannot be honored\n\n\n[1] \"\"\n\n# Librerías ----\nlibrary(shiny)\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6      ✔ purrr   0.3.4 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.0 \n✔ readr   2.1.2      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(leaflet)\nlibrary(sf)\n\nLinking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE\n\nlibrary(ggrepel)\n\n# Bases input ----\n# Encoding de latin 1 para que reconozca los asentos \n\n# Base_ ts es el histórico por delito desdel 2015 al 2022\n# con el total a nivel nacional de Carpetas O víctimas \nbase_ts <- read_rds(\"01_input/ts_delitos_prioritarios.rds\")\nEncoding(base_ts$subtipo_de_delito) <- \"latin1\"\n\n# BAse Mapa:\n# Incluye los últimos dos meses de información del SESNSP\n# con el total a nivel nacional de Carpetas O víctimas por entidad.\n# y su geometría del Marco Geoestadístico.\nbase_mapa <- read_rds(\"01_input/Mapa_scatter_delitos_prioritarios.rds\")\nbase_mapa <- sf::st_as_sf(base_mapa)\nEncoding(base_mapa$subtipo_de_delito) <- \"latin1\"\nEncoding(base_mapa$entidad) <- \"latin1\"\n\n\n# Ui \nui <- shinyUI(\n  navbarPage(\n    title = \"CentroGeo,Taller de shiny\",\n    fluid = TRUE,\n    collapsible = TRUE,\n    tabPanel(\"General\",#General\n             fluidRow(\n               tagList(\n                 div(class = \"container\",\n                     h1(\"Información General\",class = \"title fit-h1\"),\n                     p(\" La información presentada corresponde a los datos públicados por Secretariado Ejecutivo del Sistema Nacional de Seguridad Pública.\n                             Con información reportada por las Procuradurías Generales de Justicia o Fiscalías Generales de las 32 entidades federativas actualización.\n                              La información está al més de agosto 2022 y fue actualizada el 21 de septiembre del 2022 con datos del SESNSP\")))),\n             column(12,\n                    h4(\"Tipo de delito\"),\n                    selectInput(\"id_delito\",\n                                \"Selecciona un delito\",\n                                c(\"Robo a casa habitación\",\n                                  \"Robo a negocio\",                   \n                                  \"Robo a transeúnte\",                \n                                  \"Robo a transportista\",\n                                  \"Robo en transporte público colectivo\",\n                                  \"Robo en transporte público individual\",\n                                  \"Robo de vehículo automotor\",\n                                  \"Extorsión\",                         \n                                  \"Feminicidio\",                   \n                                  \"Homicidio doloso\",\n                                  \"Secuestro\"))),\n             br(),\n             column(7,\n                    leafletOutput(\"mapa\",\n                                  width = 700, height = 600)),\n             column(5,\n                    plotOutput(\"serie\",\n                               height = 300)),\n             column(5,\n                    plotOutput(\"scatter\",\n                               height = 300))\n    ))\n)\n\n# Define server logic required to draw a histogram\nserver <- function(input, output) {\n  \n  #Reactividad  de los mapas\n  b_mapa <- reactive({\n    base_mapa %>% \n      filter(fecha==as.Date(\"2022-08-01\"))\n  })\n  # Reactividad de la serie\n  b_ts <- reactive({\n    base_ts\n  })\n  # Reactividad del scatter\n  b_scatter <- reactive({\n    base_mapa\n  })\n  # Mapa leaflet\n  output$mapa <- renderLeaflet({\n    base <- b_mapa()[b_mapa()$subtipo_de_delito==input$id_delito,]\n    pal <- colorNumeric(palette = \"inferno\",domain =b_mapa()[b_mapa()$subtipo_de_delito==input$id_delito,]$Total)    \n    \n    leaflet() %>% \n      addProviderTiles(providers$OpenStreetMap) %>% \n      addPolygons(data=base$geometry,\n                  fillColor = pal(base$Total),\n                  color=\"black\",\n                  weight = 1,\n                  opacity = 1,\n                  fillOpacity = .7,\n                  label = base$NOMGEO,\n                  group = \"Entidades\")%>% \n      addLegend(pal = pal,values = base$Total) %>% \n      addLayersControl(overlayGroups = \"Entidades\")\n  })\n  # Mapa serie de tiempo\n  output$serie <- renderPlot({\n    b_ts() %>% \n      filter(subtipo_de_delito==input$id_delito) %>%\n      ggplot(aes(fecha,Total))+\n      geom_line()+\n      geom_point(data=. %>% \n                   filter(Total==max(Total)),\n                 size=3,col=\"red\"\n      )+\n      geom_point(data=. %>% \n                   filter(fecha==max(fecha)),\n                 size=3\n      )+\n      theme_classic()\n  })\n  \n  #Scatter PLot \n  \n  output$scatter <- renderPlot({\n    base <- b_scatter() %>% \n      filter(subtipo_de_delito==input$id_delito)\n    \n    ejes <- base %>% filter(Total==max(Total))\n    \n    base %>% \n      filter(subtipo_de_delito==input$id_delito) %>% \n      st_drop_geometry() %>%\n      pivot_wider(id_cols = c('clave_ent','entidad'),\n                  names_from = 'fecha',\n                  values_from = 'Total') %>% \n      ggplot(aes(`2022-07-01`,`2022-08-01`))+\n      geom_point()+\n      scale_y_continuous(limits = c(0,ejes$Total))+\n      scale_x_continuous(limits = c(0,ejes$Total))+\n      geom_abline()+\n      theme_classic()+\n      ggrepel::geom_text_repel(aes(label=entidad))\n    \n  })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\nShiny applications not supported in static R Markdown documents\n\n\nAhora, pega este código en un archivo nuevo, guárdalo como app.R (conservando la estructura de archivos de la Introducción) y listo, ya puedes correr la aplicación utilizando el botón Run App de Rstudio.\nPara ver la aplicación funcionando en vivo:\nVisualizador de delitos"
  },
  {
    "objectID": "intro_shiny.html",
    "href": "intro_shiny.html",
    "title": "Introducción",
    "section": "",
    "text": "La estructura básica de una aplicación de Shiny consiste de tres componentes:\n\nUn objeto de interfaz de usuario (UI)\nUna función de servidor (server)\nLa llamada a shinyApp\n\nVamos a empaquetar estos tres componentes en un único script: app.R.\nPodemos pensar muy en general en el siguiente esquema para entender cómo funciona una aplicación de Shiny:\n\n\n\n\nflowchart TD;\n    A(UI) <--> B(server);\n    C[(Datos)] <--> B;\n\n\n\n\n\n\n\n\nLa interfaz de usuario es lo que vemos desplegado en la página web y determina los componentes de la visualización, los elementos con los que puede interactuar el usuario y la forma en la que estos se despliegan. La función server recoge el input del usuario, va a la base de datos, hace los cómputos necesarios y regresa el resultado en forma de tablas, mapas o gráficas.\nLa conexión entre el input del usuario y las funciones de servidor se lleva a cabo a través de dos piezas fundamentales: etiquetas de HTML y funciones reactivas de Shiny. Las etiquetas controlan los lugares de la aplicación en donde se van a renderizar los componentes resultado de la interacción, mientras que las funciones reactivas consultan los datos y hacen las cuentas correspondientes.\nPara entender cómno funciona vmos a ver un ejemplo muy sencillo tomado de la documentación de quarto.\n\nLa aplicación tiene un único elemento en la interfaz de usuario: un conjunto de radio buttons y lo único que hace en el servidor es regresar el valor verbatim\nEn la siguiente sección vamos a ver un ejemplo algo más elaborado, antes de pasar a nuestra aplicación completa."
  },
  {
    "objectID": "mapa.html",
    "href": "mapa.html",
    "title": "Mapa de delitos",
    "section": "",
    "text": "library(tidyverse)\nlibrary(sf)\nlibrary(leaflet)\n\nY leyendo los datos, de la misma forma que en el diagrama de dispersión:\n\nbase_mapa <- read_rds(\"01_input/Mapa_scatter_delitos_prioritarios.rds\")\nEncoding(base_mapa$subtipo_de_delito) <- \"latin1\"\nEncoding(base_mapa$entidad) <- \"latin1\"\nhead(base_mapa)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfecha\nsubtipo_de_delito\nclave_ent\nentidad\nTotal\nCVEGEO\nNOMGEO\ngeometry\n\n\n\n\n2022-07-01\nRobo a casa habitación\n01\nAguascalientes\n164\n01\nAguascalientes\nMULTIPOLYGON (((-102.2879 2…\n\n\n2022-07-01\nRobo a casa habitación\n02\nBaja California\n294\n02\nBaja California\nMULTIPOLYGON (((-112.3007 2…\n\n\n2022-07-01\nRobo a casa habitación\n03\nBaja California Sur\n120\n03\nBaja California Sur\nMULTIPOLYGON (((-109.8945 2…\n\n\n2022-07-01\nRobo a casa habitación\n04\nCampeche\n120\n04\nCampeche\nMULTIPOLYGON (((-91.9565 20…\n\n\n2022-07-01\nRobo a casa habitación\n05\nCoahuila de Zaragoza\n140\n05\nCoahuila de Zaragoza\nMULTIPOLYGON (((-102.3108 2…\n\n\n2022-07-01\nRobo a casa habitación\n06\nColima\n123\n06\nColima\nMULTIPOLYGON (((-114.7373 1…\n\n\n\n\n\n\nUna vez más, tenemos que filtrar por tipo de delito y por fecha (recuerden que el tipo de delito lo va a determinar el usuario y la fecha la dejaremos fija)\n\nmapa_leaflet <- base_mapa %>% \n  filter(fecha==max(fecha)) %>% \n  filter(subtipo_de_delito==\"Homicidio doloso\")\nhead(mapa_leaflet)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfecha\nsubtipo_de_delito\nclave_ent\nentidad\nTotal\nCVEGEO\nNOMGEO\ngeometry\n\n\n\n\n2022-08-01\nHomicidio doloso\n01\nAguascalientes\n11\n01\nAguascalientes\nMULTIPOLYGON (((-102.2879 2…\n\n\n2022-08-01\nHomicidio doloso\n02\nBaja California\n234\n02\nBaja California\nMULTIPOLYGON (((-112.3007 2…\n\n\n2022-08-01\nHomicidio doloso\n03\nBaja California Sur\n3\n03\nBaja California Sur\nMULTIPOLYGON (((-109.8945 2…\n\n\n2022-08-01\nHomicidio doloso\n04\nCampeche\n1\n04\nCampeche\nMULTIPOLYGON (((-91.9565 20…\n\n\n2022-08-01\nHomicidio doloso\n05\nCoahuila de Zaragoza\n6\n05\nCoahuila de Zaragoza\nMULTIPOLYGON (((-102.3108 2…\n\n\n2022-08-01\nHomicidio doloso\n06\nColima\n75\n06\nColima\nMULTIPOLYGON (((-114.7373 1…\n\n\n\n\n\n\nAhora, para poder crear un mapa de coropletas, en el que los colores representen la cantidad de delitos, necesitamos una paleta de colores:\n\npal <- colorNumeric(\"inferno\", mapa_leaflet$Total, reverse = T, na.color = NA)\n\nYa con esto, crtear un mapa interactivo es muy fácil. El paquete {leaflet} toma como entrada la geometría que queremos representar, en nuestro caso, la geometría la tenemos en la columna geometry del DataFrame mapa_leaflet:\n\nhead(mapa_leaflet$geometry)\n\nGeometry set for 6 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -118.3651 ymin: 17.81287 xmax: -89.12123 ymax: 32.71865\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((-102.2879 22.41649, -102.2875 2...\n\n\nMULTIPOLYGON (((-112.3007 28.38702, -112.2983 2...\n\n\nMULTIPOLYGON (((-109.8945 22.87476, -109.8946 2...\n\n\nMULTIPOLYGON (((-91.9565 20.197, -91.95636 20.1...\n\n\nMULTIPOLYGON (((-102.3108 29.87695, -102.3105 2...\n\n\nEsta geometría internamente se transformará en un geoJSON para representarla usando Leaflet.\nAdemás de la geometría, necesitamos el valor que vamos a representar en el mapa, en este caso el Total del delito seleccionado. En este caso, la función pal que definimos arriba, convierte el valor en un color utilizando una rampa:\n\nhead(pal(mapa_leaflet$Total))\n\n[1] \"#F2F27C\" \"#0C0827\" \"#F9FC9D\" \"#FCFFA4\" \"#F5F992\" \"#F47918\"\n\n\nYa con estos elementos podemos crear un mapa de forma muy sencilla:\n\nleaflet() %>% \n  addPolygons(data=mapa_leaflet$geometry,\n              fillColor = pal(mapa_leaflet$Total),\n              color=\"black\",\n              weight = 1,\n              opacity = 1,\n              fillOpacity = .7,\n              label = mapa_leaflet$NOMGEO,\n              group = \"Entidades\")\n\n\n\n\n\nLo que estamos haciendo aquí es crear un objeto de la calse leaflet y pasarle, en addPolygons, los datos que queremos ver en el mapa junto con algunas opciones de configuración.\nEste ya es un mapa funcional pero demasiado simple, vamos a agregarle una leyenda:\n\nleaflet() %>% \n  addPolygons(data=mapa_leaflet$geometry,\n              fillColor = pal(mapa_leaflet$Total),\n              color=\"black\",\n              weight = 1,\n              opacity = 1,\n              fillOpacity = .7,\n              label = mapa_leaflet$NOMGEO,\n              group = \"Entidades\")%>% \n  addLegend(pal = pal,values = mapa_leaflet$Total)\n\n\n\n\n\nUn poco mejor, ahora agreguemos un mapa base para contextualizar el mapa. El mapa base lo vamos a agregar con la función addProviderTiles, aquí podemos ver una lista de los mapas base disponibles.\n\nleaflet() %>% \n  addProviderTiles(providers$OpenStreetMap) %>% \n  addPolygons(data=mapa_leaflet$geometry,\n              fillColor = pal(mapa_leaflet$Total),\n              color=\"black\",\n              weight = 1,\n              opacity = 1,\n              fillOpacity = .7,\n              label = mapa_leaflet$NOMGEO,\n              group = \"Entidades\")%>% \n  addLegend(pal = pal,values = mapa_leaflet$Total)"
  },
  {
    "objectID": "scatter_plot.html",
    "href": "scatter_plot.html",
    "title": "Diagrama de dispersión",
    "section": "",
    "text": "Una vez más, empezamos por cargar los paquetes que vamos a usar:\n\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(ggrepel)\n\nAhora podemos leer y explorar la base de donde vamos a sacar esta gráfica.\n\nbase_mapa <- read_rds(\"01_input/Mapa_scatter_delitos_prioritarios.rds\")\nEncoding(base_mapa$subtipo_de_delito) <- \"latin1\"\nEncoding(base_mapa$entidad) <- \"latin1\"\nhead(base_mapa)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfecha\nsubtipo_de_delito\nclave_ent\nentidad\nTotal\nCVEGEO\nNOMGEO\ngeometry\n\n\n\n\n2022-07-01\nRobo a casa habitación\n01\nAguascalientes\n164\n01\nAguascalientes\nMULTIPOLYGON (((-102.2879 2…\n\n\n2022-07-01\nRobo a casa habitación\n02\nBaja California\n294\n02\nBaja California\nMULTIPOLYGON (((-112.3007 2…\n\n\n2022-07-01\nRobo a casa habitación\n03\nBaja California Sur\n120\n03\nBaja California Sur\nMULTIPOLYGON (((-109.8945 2…\n\n\n2022-07-01\nRobo a casa habitación\n04\nCampeche\n120\n04\nCampeche\nMULTIPOLYGON (((-91.9565 20…\n\n\n2022-07-01\nRobo a casa habitación\n05\nCoahuila de Zaragoza\n140\n05\nCoahuila de Zaragoza\nMULTIPOLYGON (((-102.3108 2…\n\n\n2022-07-01\nRobo a casa habitación\n06\nColima\n123\n06\nColima\nMULTIPOLYGON (((-114.7373 1…\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n¡Esta base de datos contiene geometrías! La columna geometry contiene las coordenadas del polígono de cada estado. En esta gráfica no las vamos a usar, pero más adelante sí, para hacer un mapa.\n\n\nEsta base es muy similar a la que usamos en la serie de tiempo, sólo que viene desagregada por entidad de la república, entonces tenemos una serie de tiempo para cada estado.\nEl diagrama de dispersión que vamos a hacer compara un mes con el mes anterior, para ayudar al usuario en la comparación, vamos a agregar una diagonal que representa el caso en el que no hubo cambios entre los meses. Para agregar esta diagonal, necesitamos calcular el máximo para el delito seleccionado por el usuario:\n\neje <- base_mapa %>% \n  filter(subtipo_de_delito==\"Homicidio doloso\") %>% \n  filter(Total==max(Total))\neje\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfecha\nsubtipo_de_delito\nclave_ent\nentidad\nTotal\nCVEGEO\nNOMGEO\ngeometry\n\n\n\n\n2022-07-01\nHomicidio doloso\n11\nGuanajuato\n298\n11\nGuanajuato\nMULTIPOLYGON (((-101.35 21….\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nEn una aplicación ideal, el usuario debería poder escoger las fechas que se usan para la comparación. Por las limitaciones de tiempo de este taller, vamos a fijar estas dos fechas.\n\n\nYa con este valor calculado, vamos primero a procesar los datos para hacer nuestra gráfica. Queremos, en lugar de la serie de tiempo, un DataFrame que tenga las entidades en las filas y dos columnas con los valores que corresponden a las fechas que queremos comparar. Para eso, lo que tenemos que hacer es pivotear las tablas y pasar las fechas (que están en renglones) a columnas:\n\nbase_mapa %>% \n  filter(subtipo_de_delito==\"Homicidio doloso\") %>%\n  st_drop_geometry() %>%\n  pivot_wider(id_cols = c('clave_ent','entidad'),\n              names_from = 'fecha',\n              values_from = 'Total')\n\n\n\n\n\nclave_ent\nentidad\n2022-07-01\n2022-08-01\n\n\n\n\n01\nAguascalientes\n7\n11\n\n\n02\nBaja California\n265\n234\n\n\n03\nBaja California Sur\n2\n3\n\n\n04\nCampeche\n9\n1\n\n\n05\nCoahuila de Zaragoza\n13\n6\n\n\n06\nColima\n57\n75\n\n\n07\nChiapas\n42\n32\n\n\n08\nChihuahua\n200\n202\n\n\n09\nCiudad de México\n67\n79\n\n\n10\nDurango\n11\n14\n\n\n11\nGuanajuato\n298\n251\n\n\n12\nGuerrero\n128\n92\n\n\n13\nHidalgo\n26\n17\n\n\n14\nJalisco\n193\n175\n\n\n15\nMéxico\n210\n221\n\n\n16\nMichoacán de Ocampo\n166\n180\n\n\n17\nMorelos\n99\n88\n\n\n18\nNayarit\n13\n9\n\n\n19\nNuevo León\n120\n155\n\n\n20\nOaxaca\n89\n115\n\n\n21\nPuebla\n82\n90\n\n\n22\nQuerétaro\n16\n11\n\n\n23\nQuintana Roo\n51\n55\n\n\n24\nSan Luis Potosí\n47\n51\n\n\n25\nSinaloa\n37\n33\n\n\n26\nSonora\n141\n131\n\n\n27\nTabasco\n29\n27\n\n\n28\nTamaulipas\n41\n51\n\n\n29\nTlaxcala\n9\n12\n\n\n30\nVeracruz de Ignacio de la Llave\n86\n98\n\n\n31\nYucatán\n4\n4\n\n\n32\nZacatecas\n123\n101\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nFíjense en la llamada a st_drop_geometry(). Esta función le quita la geometría a nuestros datos, de otra forma no podríamos pivotear la tabla\n\n\nAhora sí, ya con los datos bien acomodados, podemos hacer la gráfica que queremos:\n\nbase_mapa %>% \n  filter(subtipo_de_delito==\"Homicidio doloso\") %>%\n  st_drop_geometry() %>%\n  pivot_wider(id_cols = c('clave_ent','entidad'),\n              names_from = 'fecha',\n              values_from = 'Total')  %>%\n  ggplot(aes(`2022-07-01`,`2022-08-01`))+\n  geom_point()+\n  scale_y_continuous(limits = c(0,eje$Total))+\n  scale_x_continuous(limits = c(0,eje$Total))+\n  geom_abline()+\n  theme_classic()+\n  ggrepel::geom_text_repel(aes(label=entidad))      \n\nWarning: ggrepel: 10 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\nTodos los puntos que quedan por debajo de la diagonal nos indican una disminución en el último mes, mientras que por encima nos indican un aumento."
  },
  {
    "objectID": "serie_tiempo.html",
    "href": "serie_tiempo.html",
    "title": "Serie de Tiempo",
    "section": "",
    "text": "Antes de empezar, cargamos los paquetes que vamos a usar:\n\nlibrary(tidyverse)\n\nLo primero que tenemos que hacer es leer los datos y fijar el encoding (para que funcionen bien los acentos).\n\nbase_ts <- read_rds(\"01_input/ts_delitos_prioritarios.rds\")\nEncoding(base_ts$subtipo_de_delito) <- \"latin1\"\nhead(base_ts)\n\n\n\n\n\nfecha\nsubtipo_de_delito\nTotal\n\n\n\n\n2015-01-01\nRobo a casa habitación\n7850\n\n\n2015-01-01\nRobo a negocio\n7352\n\n\n2015-01-01\nRobo a transeúnte\n6613\n\n\n2015-01-01\nRobo a transportista\n543\n\n\n2015-01-01\nRobo en transporte público colectivo\n1733\n\n\n2015-01-01\nRobo en transporte público individual\n140\n\n\n\n\n\n\nComo podemos ver, los datos son una serie de tiempo de los diferentes tipos de delitos en formato largo: la columna subtipo_de_delito discrimina los diferentes tipos de delito y la columna Total nos dice cuántos delitos hubo de ese tipo en cada periodo.\nPara poder aceptar el input del usuario y mostrar la serie de tiempo para el delito que seleccione, vamos anecesitar poder filtrar la serie por subtipo_de_delito:\n\nhead(base_ts %>% \n    filter(subtipo_de_delito == \"Homicidio doloso\"))\n\n\n\n\n\nfecha\nsubtipo_de_delito\nTotal\n\n\n\n\n2015-01-01\nHomicidio doloso\n1354\n\n\n2015-02-01\nHomicidio doloso\n1388\n\n\n2015-03-01\nHomicidio doloso\n1379\n\n\n2015-04-01\nHomicidio doloso\n1442\n\n\n2015-05-01\nHomicidio doloso\n1601\n\n\n2015-06-01\nHomicidio doloso\n1466\n\n\n\n\n\n\nYa con nuestro edlito de interés filtrado, podemos fácilmente hacer una gráfica de línea de la serie de tiempo:\n\nbase_ts %>%\n    filter(subtipo_de_delito == \"Homicidio doloso\") %>%\n    ggplot(aes(fecha, Total)) +\n        geom_line()\n\n\n\n\nMuy bien, ahora pongamos un punto rojo que nos indique el máximo de la serie de tiempo. Para esto lo primero que necesitamos es identificar la fecha en la que sucedió ese máximo.\n\nbase_ts %>% \n    filter(subtipo_de_delito == \"Homicidio doloso\") %>%\n    filter(Total == max(Total))\n\n\n\n\n\nfecha\nsubtipo_de_delito\nTotal\n\n\n\n\n2018-07-01\nHomicidio doloso\n3074\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNoten cómo estamos aquí encadenando los dos filtros, uno sobre el tipo de delito y otro sobre el total.\n\n\nAhora podemos usar ese código para agregar un geom_point en el lugar donde ocurrió el máximo. El truco es poder pasar el filtro a geom_point que recibe automaticamente los datos completos (base_ts). Para eso podemos sobreescribir el parámetro data que recibe geom_point y usar la notación especial . para referirnos a lo que recibe originalmente.\n\nbase_ts %>%\n    filter(subtipo_de_delito == \"Homicidio doloso\") %>%\n    ggplot(aes(fecha, Total)) +\n    geom_line() + \n    geom_point(data=. %>% \n               filter(Total==max(Total)),\n               size=3,col=\"red\"\n    )\n\n\n\n\nAhora sólo nos falta poner otro punto en el último valor observado para permitir al usuario comparar fácilmente el valor actual con el valor máximo.\n\nbase_ts %>%\n    filter(subtipo_de_delito == \"Homicidio doloso\") %>%\n    ggplot(aes(fecha, Total)) +\n    geom_line() + \n    geom_point(data=. %>% \n               filter(Total==max(Total)),\n               size=3,col=\"red\"\n    ) +\n    geom_point(data=. %>% \n               filter(fecha==max(fecha)),\n               size=3,col=\"black\"\n    )    \n\n\n\n\nCon esto terminamos la primera de las gráficas que queremos desplegar. En la siguiente sección vamos a hacer un diagrama de dispersión."
  }
]